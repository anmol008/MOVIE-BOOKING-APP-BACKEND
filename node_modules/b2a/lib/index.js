'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var error = function error(message) {
  function E() {
    this.message = message;
  }

  E.prototype = new Error();
  E.prototype.name = 'InvalidCharacterError';
  E.prototype.code = 5;
  return E;
};
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

var E = error('The string to be encoded contains characters out of range');
var _btoa = typeof btoa !== 'undefined'
/* istanbul ignore next */
? function (input) {
  return btoa(input);
} : function (input) {
  var str = String(input);
  var output = '';

  for ( // initialize result and counter
  var block, charCode, idx = 0, map = chars; // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1); // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);

    if (charCode > 0xFF) {
      throw new E();
    }

    block = block << 8 | charCode;
  }

  return output;
};

var utf8 = function utf8(input) {
  return encodeURIComponent(input).replace(/%([0-9A-F]{2})/g, function (match, p1) {
    return String.fromCharCode('0x' + p1);
  });
};

var btoa$1 = (function (input) {
  return _btoa(utf8(input));
});

var btoau = (function (input) {
  return btoa$1(input).replace(/\+/g, '-').replace(/\//g, '_');
});

var E$1 = error('The string to be decoded is not correctly encoded');
var _atob = typeof atob !== 'undefined'
/* istanbul ignore next */
? function (input) {
  return atob(input);
} : function (input) {
  var str = String(input).replace(/[=]+$/, '');

  if (str.length % 4 == 1) {
    throw new E$1();
  }

  var output = '';

  for ( // initialize result and counters
  var bc = 0, bs, buffer, idx = 0; // get next character
  buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;
  ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,
  // convert the first 8 bits to one ascii character
  bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
    // try to find character in table (0-63, not found => -1)
    buffer = chars.indexOf(buffer);
  }

  return output;
};

var utf16 = function utf16(input) {
  return decodeURIComponent(input.split('').map(function (c) {
    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(''));
};

var atob$1 = (function (input) {
  return utf16(_atob(input));
});

var atobu = (function (input) {
  return atob$1(input.replace(/-/g, '+').replace(/_/g, '/'));
});

exports.atob = atob$1;
exports.atobu = atobu;
exports.btoa = btoa$1;
exports.btoau = btoau;
